## Design
    CLUB50 is a website that utilizes Flask, CSS, HTML, Python, SQL, and other components. All of the componenets communicate with one another to create the website as a whole. Within the main club50 folder, we can find app.py, clubs.db, helpers.py, and requirements.txt as well as some Markdown files. clubs.db is a SQL database that contains three tables. One table, users, contains fields of id, username, hash, clubname, and cash. The id is the primary key that differentiates between all users. The very first id, id=1 will be the admin id and allows access to approval or denial of grants. It is the first account that is registered. More significantly, hash is the password hash, that allows for more secure password saving through a sort of encryption that deters malicious intenders. The clubname is then stored as well as the cash (which is actually the total of grants that have been approved for the current club/user). The next table, portfolio, contains a user_id that is associated with the id key from the users table. Then, there is a reqeustreason that is where the reason for the grant request is stored. The status is also stored in portfolio. Then, the date of the request is recorded as well as the amount of money requested. Then, there is a primary key for the protfolio element that is necessary in order to order the portfolio by the older or newest added since sorting by the date is difficult as the times and dats are cyclical. Finally, we have the forum table which includes a primary key for id, fields of user_id, the comment, clubname, the time of posting, and the email entered. 

    Next, we take a look at helpers.py, which contains functions for apology which will connect to the html template apology.html and gives it an error when there is one within app.py. There is also the login_required decorator function that can be applied to each of the app.routes within app.py that limits that route to when the user is logged in. Another decorator function called admin_required is responsible for the routes that can only be accessed by an admin. Speciffically, this is relates to the @app.route for /admin since only admins can access that. Finally, there is a function that converts values to usd format. requirments.txt helps with making sure everything runs fine.

    Within app.py, there are a variety of routes and their respective functions. The imports are all listed above and are utilized and various components are configured such as flask, SQL, and Jinja. The first route is the index, which will actually redirect to the admin page if the admin is logged in. In addtion, it is a login_required route. On the index for normal users, their specific protfoli of requests if shown using SQL and to ensure there there is no SQL injection attacks, we use ? within the db.execute. The total of their approved grants are summed using simply SQL commands, and if they are NULL then it returns zero to reduce errors. Within index.html, the portfolio is iterated through in order to get the assocaited values for the table and display the table for that specific user. Then, the color of the table row is colored accordingly to allow for better viewing of which are approved, pending, or denied (green, none, and red, respectively). This was acheived using Bootstrap documentation. 
    
    A similiar process is utilized in admin.html, however, a checkbox form is added to each row. For all the form routes, a GET or POST if statement is utlized to render the tamplates. For the route of /admin, there is a decorator of @admin required in order to allow for only the admin to be able to access the page. If the page is reached by GET, it simply gets a SQL dict of the requests from protfolio and then displays it in the HTML similiarly to index.html. Howveer, if it is reached by POST, in which case, the form was submitted (through the checkboxes), entire form's id's are gathered using request.form.getlist. Then, by iterating through all the respective id's, one can use SQL to approve or deny by checking if it is currently approved or denied by comparison to the orignal full protfolio and comparing the id's since those are also unique primary keys. Finally, it remakes admin.html in order to update the page. 

    The rest of the HTML pages follow similiar formats of input boxes except for some which require longer text answers such as comments.html and request.html which actuall have texareas that are expandable in order to allow for longer answers to show on the page instead of writing on a single line with a set width. For these "form" pages, the app.py checks to make sure that there are input and the correct inputs, then it either inserts into or update the respective SQL table within clubs.db. However, the /logout route simply clears the session from flask and makes the user sign in again. /register also checks if a certain username is taken so that users are more easily distinguished between. the /request route is made unavaible to admins by returning an error code when clickedby admins. Login checks the password with check_password_hash for security and register hashes the password within the SQL database. The time is acquired within req() using datetime, a function from datetime. 

    The forum page connects to the route of /comments, and unlike the other routes, it actually contains another Bootstrap element that was created by other users that displays the comments of the forum table. Firstly, within app.py, it takes the reqeust.method of POST or GET. If it is by GET, then it simply displays the comments. If by POST, the top also contains a form by which users can add their message to be posted as well as their email that must be of an email format. It also checks for inputs to ensure that it is an email or has a comment to be submitted. The comment is added to the SQL database with the assosicated tracking values. It is also important to note that within the profile() route, the clubname within the table of forum is updated when the user changes their clubname. This allows the forum to update the names whenever they are changed. Then, in comments.html, we find the formatting for a comment display area that also contains an email link that, when clicked, will automatically allow the user to email the clicked email. This is placed within its own Jinja block within a Jinja block of layout.html (it is only utilized in comments.html)

    Finally, within the static folder, we find the favicon.ico for the site tab. The favicon will not display when on chrome and on a local server, however it should display normally otherwise since it is automatically detected by the HTML. We also find an apple-touch icon that is also an image that is displayed on the page but next to the nav-brand. Last but not least, within style.css, we find the formatting for the page itself, witht eh background color and text colors and box/card shapes and sizes in order to ensure a better veiwing experience for the user. 